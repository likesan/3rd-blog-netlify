---
status : draft
---

삼성 알고리듬 공부 정리

![연산횟수가-적어야-좋은-알고리듬](https://user-images.githubusercontent.com/35059428/67155348-25453c00-f348-11e9-9bed-f04d5267a91f.png)


시간 복잡도도 낮아야.
시간복잡도는 어떻게 읽는걸까?
실제 실행되는 명령문의 개수를 계산한다.

## 빅오 표기법
가장 영향력을 주는 - 가장 시간이 많이 걸리는 - 가장 강력한 연산
계수는 생략하여 표기한다.
3x 라는 값이 있다면, 계수는 3이다.


![빅-O-시간-복잡도-속도비교](https://user-images.githubusercontent.com/35059428/67155415-cb457600-f349-11e9-901c-162129de393c.png)

요소 수(n)이 적을 수록, 실행되는 명령문이 적을 수록, 컴퓨터의 처리 속도가 매우 빠르다.
반대로, 연산 수가 많을 수록 속도가 너무 기하 급수적으로 느려진다.
그러니 명령하고, 연산하는 내용을 계속해서 줄여, 알고리즘의 처리를 빠르게 만드는게 중요하다.

![시간복잡도-빅-O-별로-걸리는-시간](https://user-images.githubusercontent.com/35059428/67155430-40b14680-f34a-11e9-8f41-31374ded1e35.png)

오른쪽으로, 갈 수록 연산 속도가 느리다.
대량의 정보를 계산하면 할 수록, 알고리듬의 연산을 '최적화'시켜야 속도가 빨라 느려지지 않는다.
**그래서 실력있는 개발자들은 알고리듬은 공부할 수 밖에 없는 것.**
새삼 정부 소속으로 일하는 개발자나, Nasa에서 일하는 개발자들, 컴퓨터 공학자들이 얼마나 대단한 사람들인가를 생각해보게된다...

코드 한문장 한문장이 정말 어마어마하게 느려지게 만들거나 어마어마하게 빠르게 만들 수 있다는거구나. 이런 최적화를 위해선 알고리듬을 공부할 수 밖에...


## 근데 왜 계수는 없애서 나타내는걸까?

별로 중요하지 않기 때문일까?


## 읽어보고 싶어진 책 ['알고리즘 문제해결전략'](https://book.algospot.com/)

'중요한 알고리즘과 문제 해결 기법들을 이해하기 쉽게 간결하게 설명하고 있어 초심자에게도 적합하며, 오랜 경험에서 얻을 수 있는 사소한 디테일을 돌이켜 볼 수 있기 때문에 경험자에게도 유용할 겁니다.
프로그래밍 대회 경험과 상관없이 누구에게나 추천하고 싶습니다.'

라는 추천사가 있듯,
처음 어떤 식으로 알고리듬을 대해야하는지 조금도 모르는 사람들에게 크나큰 도움이 될 것이라 본다.
다만 리디북스에는 없는 듯해서 조금 아쉽고... 밀리의 서재


## Exhaustive Search

배열에서 나온 개념.
원하는 알고리듬을 만들어내기 위해, 배열의 처음부터 끝 값까지
모두 공식에 대입해보며, 처음부터 끝까지의 모든 자료를 건드려보는 검색 방법.
Exhaustive 는 완전히 지치다 라는 뜻.
완전히 지쳐나가떨어질 정도로 Search, 검색해낸다는 뜻.
이는 Brute Force 혹은 Generate and test라는 기법으로 불린단다.
Brute Force라고 더 대중적으로 불려지는 듯도 하다.
잔혹하게, 무차별하게, 무지막지하게 라는 뜻의 Brute와 힘과 세력을 나타내는 Force.

'그냥 무식하게 처음부터 끝까지 검색해내는 기법'으로 이해하면 편할 듯.
다만 대량의 자료들을 검사하기에는 부적합. 시간 소요, 연산 소요가 심하므로 데이터량이 적은 배열에 쓰기 좋을 듯 하다.

국비서, 4자리 암호를 풀어냈던 기억이 난다.

### Exhaustive Search - Brute Force 예시

```py
/* [1,2,3] 을 포함하는 모든 순열을 생성하는 함수

for i1 from 1 to 3
    for i2 from 1 to 3
        if i2 != i1 :
            for i3 from 1 to 3
                if i3 != i2
                    print i1, i2, i3
                end if
            end for
        end if
    end for
end for
```

이렇게 한번 어떤 식으로 짜는지 이해해야
단순히 '1,2,3'을 나타내는 배열을 만드시오가 아닌 '포함하는 모든 순열을 생성하는 함수'라는 식의 표현방식에도 익숙해질 수 있는 듯. 아 '포함하는 모든 순열을 생성하는 함수'라는 어려운 말을, '그냥 배열 만들라는거구나' 라고 이해하는 능력도 알고리듬 테스트를 성공적으로 수행할 수 있는 방법 중 필수요소 인 듯.


### Greedy Algorithm


![greedy-한-선택](https://user-images.githubusercontent.com/35059428/67156722-6b58ca80-f35d-11e9-9abb-140b2c98501c.png)

Greedy Algorithm 탐욕적으로 답을 찾아나가는 알고리즘 방식. 탐욕적으로 답에 근접하다 라고 판단되는 값부터 대입해보는 문제 해결 방식을 뜻한다.
어제 소프트웨어 관련 유튜버 중 한 명이 이걸 이해하기 쉽게 설명해줬다.


[![dj-dojo-greedy-algorithm](https://user-images.githubusercontent.com/35059428/67156748-b1ae2980-f35d-11e9-936e-057f564e47a5.png)
](https://youtu.be/GBuHSRDGZBY)

두 배열의 각각 한 요소의 덧셈갓이 13에 가까운 값을 찾아내야하는 문제에서 볼 수 있는 Greedy 한 접근 방법. 중간에 답에 근접한 값을 찾아내고, 그 요소보다 작은 값들은 더 이상 건드리지 않아 모든 Brute force와는 다르게 비용이 절감되는 효과가 있는 듯.



## Sort

배열 내 자료를 오름값 혹은 내림값 순으로 정렬하는 함수를 뜻한다. Sort 란 분류한다, 정렬한다 뜻을 갖는다(영단어). ~~근데 왜 꼭 정렬을 해야하는걸까? 그 필요성 이해가 필요~~

### Bubble Sort

- Sorting 할 Array 한개를 인자로 받는다.
- 그리고 Array의 전체 크기 n을 두번째 인자로 받는다.

- 인자로 들어온 Array를 For문 내림차순(제일 큰 수에서 제일 적은 수 쪽으로)으로 돌린다.
  - python에서 range() 3번째 인자에 -1 을 넣어주면 -1씩 감소하는 for문이 만들어진다.
- 그리고 그 값에서, 맨 처음 0에서부터 n번의 큰 숫자대로 돌린다.
- 그리고 배열의 가장 0번째부터 그 다음번째(1번째) 배열과의 크기를 비교한다.
- 앞에 있는 배열 인자의 크기가 보다 크면, Temp(temporary의 약자-'임시의' 라는 뜻) 라는 변수에 임시로 넣는다. 나중에 뒷쪽에 있던 칸에 이 값을 넣기 위함.
- 뒷 칸에 있던 값을 앞으로 당겨오기 위해 array[j] = array[j+1] 을 해준다.
- 뒷 칸에 비어져버린 값은 앞 쪽에 temp를 대입해준다.

```py
def BubbleSort(array[], n):
    for i from range(n-1, n , -1) :
        for j from range(0, n) :
            if (array[j]>array[j+1]) :
                temp = array[j]
                array[j] = array[j+1] 
                array[j+1] = temp
            end if
        end for
    end for
```

이 같은 방식은 Cup 이라는 방식으로 국비 시간에 배웠던 기억이 난다.
~~음... 다 쓸모가 있었던거구나...~~


